# # Aerosol Activation Example

# ## Overview

# This example is based on AerosolActivation module which is a part of the
#   [CloudMicrophysics.jl](https://github.com/CliMA/CloudMicrophysics.jl) package.
# The AerosolActivation module computes the total number and mass
#   of aerosol particles that get activated and become cloud droplets,
#   given the atmospheric conditions and
#   the initial aerosol size distribution and properties.
# See the AerosolActivation module
#   [docs](https://clima.github.io/CloudMicrophysics.jl/dev/Aerosol_activation/)
#   for derivation and description of all input parameters.
#
# In this example we use the ensemble Kalman methods to learn
#   two parameters that describe the chemical composition of aerosol particles
#   based on the observed total number and mass of activated particles.
# The AerosolActivation model is used here in a "perfect model" setting,
#   meaning that the observations are generated by the same module
#   we are calibrating.

# ## Prerequisites

# The example depends on some standard Julia libraries,
#   as well as the CliMA packages:
#   [EnsembleKalmanProcess.jl](https://github.com/CliMA/EnsembleKalmanProcesses.jl),
#   [CLIMAParameters.jl](https://github.com/CliMA/CLIMAParameters.jl) and
#   [CloudMicrophysics.jl](https://github.com/CliMA/CloudMicrophysics.jl).
# To ensure that all the dependencies are met
#   start Julia using the Project.toml file provided in the example
#   and run the Julia package manager to download all the dependecies.

# ## Example

# We begin by importing some standard Julia modules,
# the Ensemble Kalman Process modules,
# CLIMA Parameter modules and Aerosol Activation modules.
using Plots
using Distributions
using LinearAlgebra
using Test
using Random
rng_seed = 44

import EnsembleKalmanProcesses
const EKP = EnsembleKalmanProcesses

import CLIMAParameters
const CP =  CLIMAParameters
struct EarthParameterSet <: CP.AbstractEarthParameterSet end
const param_set = EarthParameterSet()

import CloudMicrophysics
const AM = CloudMicrophysics.AerosolModel
const AA = CloudMicrophysics.AerosolActivation

# Next, we provide the information about the priors of the parameters we want to learn.
# We are calibrating two parameters decribing the aerosol properties -
# namely the aerosol molar mass and the osmotic coefficient.
parameter_names = ["molar_mass", "osmotic_coeff"]

# In this test we do know the parameter values.
# We use them to test the convergence of EKP for aerosol activation.
molar_mass_true = 0.058443
osmotic_coeff_true = 0.9
default_params = [molar_mass_true, osmotic_coeff_true]

# Both parameters have to be positive definite, therefore we
# define the constraints to be bounded below by zero.
c1 = EKP.ParameterDistributionStorage.bounded_below(0.0)
c2 = EKP.ParameterDistributionStorage.bounded_below(0.0)
constraints = [[c1], [c2]]

# We don't have any other prior knowledge about the calibrated parameters.
# Defining the prior distribution in the constrained space to be normal
# with the mean equal to zero and the standard deviation equal to one,
# ensures that the default parameter values are well within the
# assumed prior pdf.
d1 = EKP.ParameterDistributionStorage.Parameterized(Distributions.Normal(0,1))
d2 = EKP.ParameterDistributionStorage.Parameterized(Distributions.Normal(0,1))
distributions = [d1, d2]

# This concludes the setup of priors.
priors = EKP.ParameterDistributionStorage.ParameterDistribution(distributions, constraints, parameter_names);

# Next we define the atmospheric conditions for which the calibration will take place,
# (air temperature in K, air pressure in Pa vertical velocity in m/s)
# This can be changed later to include more than one (T,p,w) combination in the calibartion process
T = 283.15
p = 100000.0
w = 5.0

# We also define the aerosol size distribution (lognormal, 1 mode)
# with (mean radius in m, geometric stdev, number concentration 1/m3).
# These can also be changed later to include different initial size distributions.
r_dry = 0.243 * 1e-6
stdev = 1.4
N = 100.0 * 1e6

# Finally, we define additional parameters that describe the aerosol properties.
# The chosen aerosol is sea salt.
dissoc_seasalt = 2.0
soluble_mass_frac_seasalt = 1.0
rho_seasalt = 2170.0;

# W define a wrapper function that runs the aerosol activation module
# with two input parameters that will be calibrated by EKP.
# The output observations are the number and mass of activated aerosol.
function run_activation_model(molar_mass_calibrated, osmotic_coeff_calibrated)

    accum_mode_seasalt = AM.Mode_B(
        r_dry,
        stdev,
        N,
        (1.0,),
        (soluble_mass_frac_seasalt,),
        (osmotic_coeff_calibrated,),
        (molar_mass_calibrated,),
        (dissoc_seasalt,),
        (rho_seasalt,),
        1,
    )

    aerosol_distr = AM.AerosolDistribution((accum_mode_seasalt,))
    N_act = AA.total_N_activated(param_set, aerosol_distr, T, p, w)
    M_act = AA.total_M_activated(param_set, aerosol_distr, T, p, w)
    return [N_act, M_act]
end

# This example is run in a "perfect model setting", meaning the model that we
# calibrate is also used to generate observations.
# We use the total number and mass of activated aerosol particles as
# our observational data.
observation_data_names = ["N_act", "M_act"];

# We generate artificial truth samples based on the default values
# of parameters we are calibrating.
n_samples = 10
G_t = run_activation_model(molar_mass_true, osmotic_coeff_true)
y_t = zeros(length(G_t), n_samples)

Γy = convert(Array, LinearAlgebra.Diagonal([0.01 * G_t[1], 0.01 * G_t[2]]))
μ = zeros(length(G_t));

# And add noise to the generated truth sample.
for i in 1:n_samples
    y_t[:, i] = G_t .+ rand(Distributions.MvNormal(μ, Γy))
end

truth_array = EKP.Observations.Obs(y_t, Γy, observation_data_names)

# One could try for the truth to be a mean of the generated array.
# Or do the calibration for all individual truth samples and then
# compute the mean of calibrated parameters.
# For now we are just taking one truth array member.
truth_sample = truth_array.samples[1];

# We use 50 ensemble members and do 10 iterations.
N_ens = 50
N_iter = 10

initial_par = EKP.EnsembleKalmanProcessModule.construct_initial_ensemble(
    priors,
    N_ens;
    rng_seed
)
ekiobj = EKP.EnsembleKalmanProcessModule.EnsembleKalmanProcess(
    initial_par,
    truth_sample,
    truth_array.obs_noise_cov, EKP.EnsembleKalmanProcessModule.Inversion(),
    Δt=1
)

# Finally, we can run the Ensemble Kalman Process calibration.
ϕ_n_values = []
for n in 1:N_iter
    θ_n = EKP.EnsembleKalmanProcessModule.get_u_final(ekiobj)

    ϕ_n = mapslices(
        x -> EKP.ParameterDistributionStorage.transform_unconstrained_to_constrained(priors, x),
        θ_n;
        dims=1
    )

    G_n = [run_activation_model(ϕ_n[:, i]...) for i in 1:N_ens]

    G_ens = hcat(G_n...)
    EKP.EnsembleKalmanProcessModule.update_ensemble!(ekiobj, G_ens)

    global ϕ_n_values = vcat(ϕ_n_values, [ϕ_n])
end

# We define some simple functions for plotting the data.
function plot_ensemble_scatter(id)

    ensemble_member = range(1, N_ens, length=N_ens)

    ylabel = "TODO"
    title = "TODO"
    if id == 1
        ylabel = "Molar mass [kg/mol]"
        title = "molar_mass_scatter.svg"
    end
    if id == 2
        ylabel = "Osmotic coefficient [-]"
        title = "osmotic_coeff_scatter.svg"
    end

    plot(ensemble_member, ϕ_n_values[1][id,1:N_ens],
          seriestype=:scatter, xlabel="Ensemble Number", ylabel=ylabel, leg=false
         )
    for it in range(2, N_iter, length=N_iter-1)
        it = Int(it)
        plot!(ensemble_member.+((it-1)*50), ϕ_n_values[it][id, 1:N_ens], seriestype=:scatter, leg=false)
    end

    current()
    savefig(title)
end

function plot_ensemble_means(id)

    number_of_iters = range(1, N_iter, length=N_iter)
    means = zeros(N_iter)

    for it in range(1, N_iter, length=N_iter)
        it = Int(it)
        means[it] = mean(ϕ_n_values[it][id,1:N_ens])
    end

    ylabel = "TODO"
    title = "TODO"
    if id == 1
        ylabel = "Molar mass [kg/mol]"
        title = "molar_mas_average.svg"
    end
    if id == 2
        ylabel = "Osmotic coefficient [-]"
        title = "osmotic_coeff_average.svg"
    end

    plot(number_of_iters, means, xlabel = "ensemble number", ylabel = ylabel, label = "enseble mean")
    hline!([default_params[id]], label="true value")
    savefig(title)
end;

# We plot the ensemble members and the ensemble mean for the
# molar mass and osmotic coefficient.
plot_ensemble_scatter(1)
plot_ensemble_means(1)
plot_ensemble_scatter(2)
plot_ensemble_means(2)
# ![](molar_mass_scatter.svg)
# ![](osmotic_coeff_scatter.svg)
# ![](molar_mass_average.svg)
# ![](osmotic_coeff_average.svg)

# Finally we test that the parameter values obtained via EKP.jl are close
# to the known true parameter values.
molar_mass_ekp = mean(ϕ_n_values[N_iter][1, 1:N_ens])
osmotic_coeff_ekp = mean(ϕ_n_values[N_iter][2, 1:N_ens])

println(molar_mass_ekp, " vs ", molar_mass_true)
println(osmotic_coeff_ekp, " vs ", osmotic_coeff_true)

#@test isapprox(molar_mass_ekp, molar_mass_true, rtol = 0.2)
#@test isapprox(osmotic_coeff_ekp, osmotic_coeff_true, rtol = 0.1)

