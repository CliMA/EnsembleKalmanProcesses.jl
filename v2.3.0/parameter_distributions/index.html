<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Prior distributions · EnsembleKalmanProcesses.jl</title><meta name="title" content="Prior distributions · EnsembleKalmanProcesses.jl"/><meta property="og:title" content="Prior distributions · EnsembleKalmanProcesses.jl"/><meta property="twitter:title" content="Prior distributions · EnsembleKalmanProcesses.jl"/><meta name="description" content="Documentation for EnsembleKalmanProcesses.jl."/><meta property="og:description" content="Documentation for EnsembleKalmanProcesses.jl."/><meta property="twitter:description" content="Documentation for EnsembleKalmanProcesses.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="EnsembleKalmanProcesses.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">EnsembleKalmanProcesses.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation_instructions/">Installation instructions</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../literated/sinusoid_example/">Simple example</a></li><li><a class="tocitem" href="../examples/Cloudy_example/">Cloudy</a></li><li><a class="tocitem" href="../examples/lorenz_example/">Lorenz</a></li><li><a class="tocitem" href="../literated/loss_minimization/">Minimization Loss</a></li><li><a class="tocitem" href="../literated/loss_minimization_sparse_eki/">Sparse Minimization Loss</a></li><li><a class="tocitem" href="../literated/aerosol_activation/">Aerosol activation</a></li><li><a class="tocitem" href="../examples/darcy/">Darcy flow</a></li><li><a class="tocitem" href="../examples/sinusoid_example_toml/">TOML interface</a></li><li><a class="tocitem" href="../examples/ClimateMachine_example/">HPC interfacing example: ClimateMachine</a></li><li><a class="tocitem" href="../examples/template_example/">Template</a></li></ul></li><li><a class="tocitem" href="../defaults/">List of default configurations</a></li><li><a class="tocitem" href="../ensemble_kalman_inversion/">Ensemble Kalman Inversion</a></li><li><a class="tocitem" href="../gauss_newton_kalman_inversion/">Gauss Newton Kalman Inversion</a></li><li><a class="tocitem" href="../ensemble_kalman_sampler/">Ensemble Kalman Sampler</a></li><li><a class="tocitem" href="../unscented_kalman_inversion/">Unscented Kalman Inversion</a></li><li><a class="tocitem" href="../learning_rate_scheduler/">Learning rate schedulers</a></li><li class="is-active"><a class="tocitem" href>Prior distributions</a><ul class="internal"><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li><li><a class="tocitem" href="#ParameterDistribution-struct"><span>ParameterDistribution struct</span></a></li><li><a class="tocitem" href="#ParameterDistribution-constructor"><span>ParameterDistribution constructor</span></a></li><li><a class="tocitem" href="#ParameterDistribution-methods"><span>ParameterDistribution methods</span></a></li><li><a class="tocitem" href="#Additional-Examples"><span>Additional Examples</span></a></li><li><a class="tocitem" href="#function-example"><span>Function Distribution Example</span></a></li><li><a class="tocitem" href="#ConstraintType-Examples"><span>ConstraintType Examples</span></a></li></ul></li><li><a class="tocitem" href="../observations/">Observations and Minibatching</a></li><li><a class="tocitem" href="../update_groups/">Update Groups</a></li><li><a class="tocitem" href="../localization/">Localization and SEC</a></li><li><a class="tocitem" href="../accelerators/">Accelerators</a></li><li><a class="tocitem" href="../inflation/">Inflation</a></li><li><a class="tocitem" href="../parallel_hpc/">Parallelism and HPC</a></li><li><a class="tocitem" href="../internal_data_representation/">Internal data representation</a></li><li><a class="tocitem" href="../troubleshooting/">Troubleshooting</a></li><li><input class="collapse-toggle" id="menuitem-19" type="checkbox"/><label class="tocitem" for="menuitem-19"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../API/ParameterDistributions/">ParameterDistributions</a></li><li><a class="tocitem" href="../API/Observations/">Observations</a></li><li><a class="tocitem" href="../API/DataContainers/">DataContainers</a></li><li><a class="tocitem" href="../API/EnsembleKalmanProcess/">EnsembleKalmanProcess</a></li><li><a class="tocitem" href="../API/Inversion/">Inversion</a></li><li><a class="tocitem" href="../API/Unscented/">Unscented</a></li><li><a class="tocitem" href="../API/Sampler/">Sampler</a></li><li><a class="tocitem" href="../API/SparseInversion/">SparseInversion</a></li><li><a class="tocitem" href="../API/TOMLInterface/">TOML Interface</a></li><li><a class="tocitem" href="../API/Localizers/">Localizers</a></li></ul></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../glossary/">Glossary</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Prior distributions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Prior distributions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CliMA/EnsembleKalmanProcesses.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CliMA/EnsembleKalmanProcesses.jl/blob/main/docs/src/parameter_distributions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="parameter-distributions"><a class="docs-heading-anchor" href="#parameter-distributions">Defining prior distributions</a><a id="parameter-distributions-1"></a><a class="docs-heading-anchor-permalink" href="#parameter-distributions" title="Permalink"></a></h1><p>Bayesian inference begins with an explicit prior distribution. This page describes the interface EnsembleKalmanProcesses provides for specifying priors on parameters, via the ParameterDistributions module (<code>src/ParameterDistributions.jl</code>).</p><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><h3 id="ParameterDistribution-objects"><a class="docs-heading-anchor" href="#ParameterDistribution-objects">ParameterDistribution objects</a><a id="ParameterDistribution-objects-1"></a><a class="docs-heading-anchor-permalink" href="#ParameterDistribution-objects" title="Permalink"></a></h3><p>A prior is specified by a <code>ParameterDistribution</code> object, which has three components:</p><ol><li>The distribution itself, given as a <a href="#ParameterDistributionType">ParameterDistributionType</a> object. This includes standard Julia <a href="https://juliastats.org/Distributions.jl/stable/">Distributions</a>, <a href="https://github.com/PieterjanRobbe/GaussianRandomFields.jl">GaussianRandomFields</a> as well as empirical/sample-based distributions, and thus can be univariate, multivariate or functional. To clarify, despite our use of the term &quot;Kalman processes,&quot; the prior distribution is <em>not</em> required to be Gaussian.</li><li>A constraint (or array of constraints) on the domain of the distribution, given as a <a href="#ConstraintType">ConstraintType</a> or <code>Array{ConstraintType}</code> object (the latter case builds a multivariate constraint as the Cartesian product of one-dimensional Constraints). This is used to enforce physical parameter values during inference: the model is never evaluated at parameter values outside the constrained region, and the posterior distribution will only be supported there.</li><li>The parameter name, given as a <code>String</code>.</li></ol><p>In multiparameter settings, one should define one <code>ParameterDistribution</code> per parameter, and then concatenate these either in the constructor or with <code>combine_distributions</code>. This is illustrated below and in the <a href="#Example-combining-several-distributions">Example combining several distributions</a>.</p><div class="admonition is-info"><header class="admonition-header">What&#39;s up with the notation u, ϕ, and θ?</header><div class="admonition-body"><p>Parameters in unconstrained spaces are often denoted <span>$u$</span> or <span>$\theta$</span> in the literature. In the code, method names featuring <code>_u</code> imply the return of a computational, unconstrained parameter.</p><p>Parameters in physical/constrained spaces are often denoted <span>$\mathcal{T}^{-1}(u)$</span>, <span>$\mathcal{T}^{-1}(\theta)$</span>, or <span>$\phi$</span> in the literature (for some bijection <span>$\mathcal{T}$</span> mapping to the unbounded space). In the code, method names featuring <code>_ϕ</code> imply the return of a physical, constrained parameter, and will always require a <code>prior</code> as input to perform the transformations internally.</p><p>For more notations see our <a href="../glossary/#Glossary">Glossary</a>.</p></div></div><h3 id="constrained-gaussian"><a class="docs-heading-anchor" href="#constrained-gaussian">Recommended constructor</a><a id="constrained-gaussian-1"></a><a class="docs-heading-anchor-permalink" href="#constrained-gaussian" title="Permalink"></a></h3><p><code>constrained_gaussian()</code> is a streamlined constructor for <code>ParameterDistribution</code>s which addresses the most common use case; more general forms of the constructor are documented below, but we <strong>highly</strong> recommend that users begin here when it comes to specifying priors, only using the general constructor when necessary.</p><p>Usage:</p><pre><code class="language-julia hljs">using EnsembleKalmanProcesses.ParameterDistributions # for `constrained_gaussian`, `combine_distributions`
prior_1 = constrained_gaussian(&quot;param_1&quot;, μ_1, σ_1, lower_bound, upper_bound)
prior_2 = constrained_gaussian(&quot;param_2&quot;, μ_2, σ_2, 0.0, Inf, repeats=3)
prior = combine_distributions([prior_1, prior_2])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ParameterDistribution with 2 entries: 
&#39;param_1&#39; with EnsembleKalmanProcesses.ParameterDistributions.Constraint[Bounds: (0.0, 1.0)] over distribution EnsembleKalmanProcesses.ParameterDistributions.Parameterized(Distributions.Normal{Float64}(μ=-8.166022598761285e-6, σ=1.3125811715866231)) 
&#39;param_2&#39; with EnsembleKalmanProcesses.ParameterDistributions.Constraint[Bounds: (0.0, ∞), Bounds: (0.0, ∞), Bounds: (0.0, ∞)] over distribution EnsembleKalmanProcesses.ParameterDistributions.VectorOfParameterized{Distributions.Normal{Float64}}(Distributions.Normal{Float64}[Distributions.Normal{Float64}(μ=-0.8047189562170501, σ=0.47238072707743883), Distributions.Normal{Float64}(μ=-0.8047189562170501, σ=0.47238072707743883), Distributions.Normal{Float64}(μ=-0.8047189562170501, σ=0.47238072707743883)]) 
</code></pre><p><code>prior_1</code> is a <code>ParameterDistribution</code> describing a prior distribution for a parameter named <code>&quot;param_1&quot;</code> taking values on the interval [<code>lower_bound</code>, <code>upper_bound</code>]; the prior distribution has approximate mean <span>$μ_1$</span> and standard deviation <span>$σ_1$</span>.</p><p><code>prior_2</code> is a <code>ParameterDistribution</code> describing a 3-dimensional prior distribution for a parameter named <code>&quot;param_2&quot;</code> with each dimensions taking independent values on the half-open interval [<code>0.0</code>, <code>Inf</code>); the marginals of this prior distribution have approximate mean <span>$μ_2$</span> and standard deviation <span>$σ_2$</span>.</p><p>The use case <code>constrained_gaussian()</code> addresses is when prior information is qualitative, and exact distributions of the priors are unknown: i.e., the user is only able to specify the physical and likely ranges of prior parameter values at a rough, qualitative level. <code>constrained_gaussian()</code> does this by constructing a <code>ParameterDistribution</code> corresponding to a Gaussian &quot;squashed&quot; to fit in the given constraint interval, such that the &quot;squashed&quot; distribution has the specified mean and standard deviation (e.g. <code>prior_2</code> above is a log-normal for each dimension).</p><p>The parameters of the Gaussian are chosen automatically (depending on the constraint) to reproduce the desired μ and σ — per the use case, other details of the form of the prior distribution shouldn&#39;t be important for downstream inference!                </p><div class="admonition is-info"><header class="admonition-header">Slow/Failed construction?</header><div class="admonition-body"><p>The most common case of slow or failed construction is when requested parameters place too much mass at the hard boundary. A typical case is when the requested variance satisfies <span>$|\sigma| \approx \mathrm{dist}(\mu,\mathrm{boundary})$</span> Such priors can be defined, but not with our convenience constructor. If this is not the case but you still get failures please let us know!</p></div></div><h3 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h3><p>For quick visualization we have a plot recipe for <code>ParameterDistribution</code> types. This will plot marginal histograms for all dimensions of the parameter distribution. For example, </p><pre><code class="language-julia hljs"># with values:
# e.g. lower_bound = 0.0, upper_bound = 1.0
# μ_1 = 0.5, σ_1 = 0.25
# μ_2 = 0.5, σ_2 = 0.25

using Plots
plot(prior)</code></pre><img src="2adf9294.svg" alt="Example block output"/><p>One can also access the underlying Gaussian distributions in the unconstrained space with</p><pre><code class="language-julia hljs">using Plots
plot(prior, constrained=false)</code></pre><img src="0c0978cd.svg" alt="Example block output"/><h3 id="Recommended-constructor-Simple-example"><a class="docs-heading-anchor" href="#Recommended-constructor-Simple-example">Recommended constructor - Simple example</a><a id="Recommended-constructor-Simple-example-1"></a><a class="docs-heading-anchor-permalink" href="#Recommended-constructor-Simple-example" title="Permalink"></a></h3><p>Task: We wish to create a prior for a one-dimensional parameter. Our problem dictates that this parameter is bounded between 0 and 1; domain knowledge leads us to expect it should be around 0.7. The parameter is called <code>point_seven</code>.</p><p>We&#39;re told that the prior mean is 0.7; we choose a prior standard deviation of 0.15 to be sufficiently wide without putting too much mass at the upper bound. The constructor is then</p><pre><code class="language-julia hljs">using EnsembleKalmanProcesses.ParameterDistributions # for `constrained_gaussian`
prior = constrained_gaussian(&quot;point_seven&quot;, 0.7, 0.15, 0.0, 1.0)</code></pre><p>The pdf of the constructed prior distribution (in the physical, constrained space) looks like:</p><img src="05853d54.svg" alt="Example block output"/><p>In <a href="#Simple-example-revisited">Simple example revisited</a> below, we repeat this example &quot;manually&quot; with the general constructor.</p><div class="admonition is-info"><header class="admonition-header">What if I want to impose the same prior on many parameters?</header><div class="admonition-body"><p>The recommended constructor can be called as <code>constrained_gaussian(...; repeats = n)</code> to return a combined prior formed by <code>n</code> identical priors.</p></div></div><h2 id="ParameterDistribution-struct"><a class="docs-heading-anchor" href="#ParameterDistribution-struct">ParameterDistribution struct</a><a id="ParameterDistribution-struct-1"></a><a class="docs-heading-anchor-permalink" href="#ParameterDistribution-struct" title="Permalink"></a></h2><p>This section provides more details on the components of a <code>ParameterDistribution</code> object.</p><h3 id="ParameterDistributionType"><a class="docs-heading-anchor" href="#ParameterDistributionType">ParameterDistributionType</a><a id="ParameterDistributionType-1"></a><a class="docs-heading-anchor-permalink" href="#ParameterDistributionType" title="Permalink"></a></h3><p>The <code>ParameterDistributionType</code> struct wraps four types for specifying different types of prior distributions:</p><ul><li><p>The <code>Parameterized</code> type is initialized using a Julia <code>Distributions.jl</code> object. Samples are drawn randomly from the distribution object.</p></li><li><p>The <code>VectorOfParameterized</code> type is initialized with a vector of distributions.</p></li><li><p>The <code>Samples</code> type is initialized using a two dimensional array. Samples are drawn randomly (with replacement) from the columns of the provided array.</p></li><li><p>The <code>FunctionParameterDistributionType</code> struct defines parameters specified as fields over a domain. More detail can be found <a href="#function-parameter-type">here</a>.</p></li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>We recommend that the distributions be unbounded (see next section), as the filtering algorithms in EnsembleKalmanProcesses are not guaranteed to preserve constraints unless defined through the <code>ConstraintType</code> mechanism.</p></div></div><h3 id="ConstraintType"><a class="docs-heading-anchor" href="#ConstraintType">ConstraintType</a><a id="ConstraintType-1"></a><a class="docs-heading-anchor-permalink" href="#ConstraintType" title="Permalink"></a></h3><p>The inference algorithms implemented in EnsembleKalmanProcesses assume unbounded parameter domains. To be able to handle constrained parameter values consistently, the <code>ConstraintType</code>  defines a bijection between the physical, constrained parameter domain and an unphysical, unconstrained domain in which the filtering takes place. This bijection is specified by the functions <code>transform_constrained_to_unconstrained</code> and <code>transform_unconstrained_to_constrained</code>, which are built from either predefined constructors or user-defined constraint functions given as arguments to the <code>ConstraintType</code> constructor. </p><p>We provide the following predefined constructors which implement mappings that handle the most common constraints:</p><ul><li><code>no_constraint()</code>: The parameter is unconstrained and takes values in (-∞, ∞) (mapping is the identity).</li><li><code>bounded_below(lower_bound)</code>: The parameter takes values in [<code>lower_bound</code>, ∞).</li><li><code>bounded_above(upper_bound)</code>: The parameter takes values in (-∞, <code>upper_bound</code>].</li><li><code>bounded(lower_bound,upper_bound)</code>: The parameter takes values on the interval [<code>lower_bound</code>, <code>upper_bound</code>].</li></ul><p>These are demonstrated in <a href="#ConstraintType-Examples">ConstraintType Examples</a>.</p><p>Currently we only support multivariate constraints which are the Cartesian product of the one-dimensional <code>ConstraintType</code>s. Every component of a multidimensional parameter must have an associated constraint, so, e.g. for a multivariate <code>ParameterDistributionType</code> of dimension <code>p</code> the user must provide a <code>p-</code>dimensional <code>Array{ConstraintType}</code>. A <code>VectorOfParameterized</code> distribution built with distributions of dimension <code>p</code> and <code>q</code> has dimension <code>p+q</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When a nontrivial <code>ConstraintType</code> is given, the general constructor assumes the <code>ParameterDistributionType</code> is specified in the <em>unconstrained</em> space; the actual prior pdf is then the composition of the <code>ParameterDistributionType</code>&#39;s pdf with the <code>transform_unconstrained_to_constrained</code> transformation. We provide <code>constrained_gaussian</code> to define priors directly in the physical, constrained space.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is up to the user to ensure any custom mappings <code>transform_constrained_to_unconstrained</code> and <code>transform_unconstrained_to_constrained</code> are inverses of each other.</p></div></div><h3 id="The-name"><a class="docs-heading-anchor" href="#The-name">The name</a><a id="The-name-1"></a><a class="docs-heading-anchor-permalink" href="#The-name" title="Permalink"></a></h3><p>This is simply a <code>String</code> used to identify different parameters in multi-parameter situations, as in the methods below.</p><h3 id="function-parameter-type"><a class="docs-heading-anchor" href="#function-parameter-type">FunctionParameterDistributionType</a><a id="function-parameter-type-1"></a><a class="docs-heading-anchor-permalink" href="#function-parameter-type" title="Permalink"></a></h3><p>Learning a function distribution is useful when one wishes to obtain a parametric representation of a function that is (relatively) agnostic of the underlying grid discretization. Most practical implementations involve posing a restrictive class of functions by truncation of a spectral decomposition. The function is then represented as a set of coefficients of these modes (known as degrees of freedom), rather than directly through the values at evaluation points.</p><p>As a subtype of <code>ParameterDistributionType</code>, we currently support one option for specifying prior distributions over functions:</p><ul><li>The <code>GaussianRandomFieldInterface</code> type is initialized with a Gaussian Random Field object and the GRF package. Currently we support objects from <a href="https://github.com/PieterjanRobbe/GaussianRandomFields.jl"><code>GaussianRandomFields.jl</code></a> with package <code>GRFJL()</code>. Gaussian random fields allow the definition of scalar function distributions defined over a uniform mesh on interval, rectangular, and hyper-rectangular domains.</li></ul><p>As with other <code>ParameterDistribution</code>s, a function distribution, is built from a name, a <code>FunctionPameterDistributionType</code> struct and a constraint, here only one, placed on the scalar output space of the function using a <code>Constraint()</code>.</p><div class="admonition is-info"><header class="admonition-header">constraints</header><div class="admonition-body"><p>The transformation <code>transform_unconstrained_to_constrained</code>, will map from (unconstrained) degrees of freedom, to (constrained) evaluations of the function on a numerical grid. In particular, the <code>transform_constrained_to_unconstrained</code> is <em>no longer the inverse</em> of this map, it now simply maps from constrained evaluations to unconstrained evaluations on the grid.</p></div></div><p>We provide an example construction <a href="#function-example">here</a>.</p><h2 id="ParameterDistribution-constructor"><a class="docs-heading-anchor" href="#ParameterDistribution-constructor">ParameterDistribution constructor</a><a id="ParameterDistribution-constructor-1"></a><a class="docs-heading-anchor-permalink" href="#ParameterDistribution-constructor" title="Permalink"></a></h2><p>The <a href="#constrained-gaussian">Recommended constructor</a>, <code>constrained_gaussian()</code>, is described above. For more general cases in which the prior needs to be specified in more detail, a <code>ParameterDistribution</code> may be constructed &quot;manually&quot; from its component objects:</p><pre><code class="language-julia hljs">using EnsembleKalmanProcesses.ParameterDistributions # for `ParameterDistribution`, `combine_distributions`
prior_1 = ParameterDistribution(distribution_1, constraint_1, name_1)
prior_2 = ParameterDistribution(distribution_2, constraint_2, name_2)
prior = combine_distributions( [prior_1, prior_2])</code></pre><p>Arguments may also be provided as a <code>Dict</code>:</p><pre><code class="language-julia hljs">using EnsembleKalmanProcesses.ParameterDistributions # for `ParameterDistribution`
dict_1 = Dict(&quot;distribution&quot; =&gt; distribution_1, &quot;constraint&quot; =&gt; constraint_1, &quot;name&quot; =&gt; name_1)
dict_2 = Dict(&quot;distribution&quot; =&gt; distribution_2, &quot;constraint&quot; =&gt; constraint_2, &quot;name&quot; =&gt; name_2)
prior = ParameterDistribution( [dict_1, dict_2] )</code></pre><p>We provide <a href="#Additional-Examples">Additional Examples</a> below; see also examples in the package <code>examples/</code> and unit tests found in <code>test/ParameterDistributions/runtests.jl</code>.</p><h2 id="ParameterDistribution-methods"><a class="docs-heading-anchor" href="#ParameterDistribution-methods">ParameterDistribution methods</a><a id="ParameterDistribution-methods-1"></a><a class="docs-heading-anchor-permalink" href="#ParameterDistribution-methods" title="Permalink"></a></h2><p>These functions typically return a <code>Dict</code> with <code>ParameterDistribution.name</code> as a keys, or an <code>Array</code> if requested:</p><ul><li><code>get_name</code>: returns the name(s) of parameters in the <code>ParameterDistribution</code>.</li><li><code>get_distribution</code>: returns the distributions (<code>ParameterDistributionType</code> objects) in the <code>ParameterDistribution</code>. Note that this is <em>not</em> the prior pdf used for inference if nontrivial constraints have been applied.</li><li><code>mean, var, cov, sample, logpdf</code>: mean, variance, covariance, logpdf or samples the Julia Distribution if <code>Parameterized</code>, or draws from the list of samples if <code>Samples</code>. Extends the StatsBase definitions. Note that these do <em>not</em> correspond to the prior pdf used for inference if nontrivial constraints have been applied.</li><li><code>transform_unconstrained_to_constrained</code>: Applies the constraint mappings.</li><li><code>transform_constrained_to_unconstrained</code>: Applies the inverse constraint mappings.</li></ul><h2 id="Additional-Examples"><a class="docs-heading-anchor" href="#Additional-Examples">Additional Examples</a><a id="Additional-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-Examples" title="Permalink"></a></h2><h3 id="Simple-example-revisited"><a class="docs-heading-anchor" href="#Simple-example-revisited">Simple example revisited</a><a id="Simple-example-revisited-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-example-revisited" title="Permalink"></a></h3><p>To illustrate what the <code>constrained_gaussian</code> constructor is doing, in this section we repeat the <a href="#Recommended-constructor-Simple-example">Recommended constructor - Simple example</a> given above, using the &quot;manual,&quot; general-purpose constructor. Let&#39;s bring in the packages we will require</p><pre><code class="language-julia hljs">using EnsembleKalmanProcesses.ParameterDistributions # for `bounded`, `Parameterized`, and `ParameterDistribution`
using Distributions # for `Normal`</code></pre><p>Then we initialize the constraint first,</p><pre><code class="language-julia hljs">constraint = bounded(0, 1)</code></pre><p>This defines the following transformation to the  constrained space (and also its inverse)</p><pre><code class="language-julia hljs">transform_unconstrained_to_constrained(x) = exp(x) / (exp(x) + 1)</code></pre><p>The prior mean should be around 0.7 (in the constrained space), and one can find that the push-forward of a particular normal distribution, namely, <code>transform_unconstrained_to_constrained(Normal(mean = 1, sd = 0.5))</code> gives a prior pdf with 95% of its mass between [0.5, 0.88]. </p><p>This is the main difference from the use of the <code>constrained_gaussian</code> constructor: in that example, the constructor numerically solved for the parameters of the Normal() which would reproduce the requested μ, σ for the physical, constrained quantity (since no closed-form transformation for the moments exists.)</p><pre><code class="language-julia hljs">distribution = Parameterized(Normal(1, 0.5))</code></pre><p>Finally we attach the name</p><pre><code class="language-julia hljs">name = &quot;point_seven&quot;</code></pre><p>and the distribution is created by either:</p><pre><code class="language-julia hljs">prior = ParameterDistribution(distribution, constraint, name)</code></pre><p>or</p><pre><code class="language-julia hljs">prior_dict = Dict(&quot;distribution&quot; =&gt; distribution, &quot;constraint&quot; =&gt; constraint, &quot;name&quot; =&gt; name)
prior = ParameterDistribution(prior_dict)</code></pre><p>The pdf of the Normal distribution and its transform to the physical, constrained space are:</p><img src="95ab50b3.svg" alt="Example block output"/><h3 id="samples-example"><a class="docs-heading-anchor" href="#samples-example">Sample-based distribution</a><a id="samples-example-1"></a><a class="docs-heading-anchor-permalink" href="#samples-example" title="Permalink"></a></h3><p>We repeat the work of <a href="#Simple-example-revisited">Simple example revisited</a>, but now assuming that to create our prior, we only have samples given by the histogram:</p><img src="f806d328.svg" alt="Example block output"/><p>Imagine we <strong>do not know</strong> this distribution is bounded. To create a <code>ParameterDistribution</code> one can take a matrix <code>constrained_samples</code> whose columns are this data:</p><pre><code class="language-julia hljs">using EnsembleKalmanProcesses.ParameterDistributions # for `Samples`, `no_constraint`, `ParameterDistribution`, `bounded`
distribution = Samples(constrained_samples)
constraint = no_constraint()
name = &quot;point_seven&quot;
prior = ParameterDistribution(distribution, constraint, name)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This naive implementation will not enforce any boundaries during the algorithm implementation.</p></div></div><p>Imagine that we <strong>know</strong> about the boundedness of this distribution, then, as in <a href="#Simple-example-revisited">Simple example revisited</a>, we define the constraint</p><pre><code class="language-julia hljs">constraint = bounded(0, 1)</code></pre><p>which stores the transformation:</p><pre><code class="language-julia hljs">unconstrained_samples = constraint.constrained_to_unconstrained.(constrained_samples)</code></pre><p>This maps the samples into an unbounded space, giving the following histogram:</p><img src="8fd6cd50.svg" alt="Example block output"/><p>As before we define a <code>Samples</code> distribution from matrix whose columns are the (now unconstrained) samples, along with a name to create the <code>ParameterDistribution</code>.</p><pre><code class="language-julia hljs">distribution = Samples(unconstrained_samples)
name = &quot;point_seven&quot;
prior = ParameterDistribution(distribution, constraint, name)</code></pre><h3 id="Example-combining-several-distributions"><a class="docs-heading-anchor" href="#Example-combining-several-distributions">Example combining several distributions</a><a id="Example-combining-several-distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Example-combining-several-distributions" title="Permalink"></a></h3><p>To show how to combine priors in a more complex setting (e.g. for an entire parametrized process), we create a 25-dimensional parameter distribution from three dictionaries.</p><p>Bring in the packages!</p><pre><code class="language-julia hljs">using EnsembleKalmanProcesses.ParameterDistributions
# for `bounded_below`, `bounded`, `Constraint`, `no_constraint`,
#     `Parameterized`, `Samples`,`VectorOfParameterized`,
#     `ParameterDistribution`, `combine_distributions`
using LinearAlgebra  # for `SymTridiagonal`, `Matrix`
using Distributions # for `MvNormal`, `Beta`</code></pre><p>The first parameter is a 3-dimensional distribution, with the following bound constraints on parameters in physical space:</p><pre><code class="language-julia hljs">c1 = repeat([bounded_below(0)], 3)</code></pre><p>We know that a multivariate normal represents its distribution in the transformed (unbounded) space. Here we take a tridiagonal covariance matrix.</p><pre><code class="language-julia hljs">diagonal_val = 0.5 * ones(3)
udiag_val = 0.25 * ones(2)
mean = ones(3)
covariance = Matrix(SymTridiagonal(diagonal_val, udiag_val))
d1 = Parameterized(MvNormal(mean, covariance)) # 3D multivariate normal</code></pre><p>We also provide a name</p><pre><code class="language-julia hljs">name1 = &quot;constrained_mvnormal&quot;</code></pre><p>The second parameter is a 2-dimensional one. It is only given by 4 samples in the transformed space - (where one will typically generate samples). It is bounded in the first dimension by the constraint shown, there is a user provided transform for the second dimension - using the default constructor.</p><pre><code class="language-julia hljs">d2 = Samples([1.0 5.0 9.0 13.0; 3.0 7.0 11.0 15.0]) # 4 samples of 2D parameter space

transform = (x -&gt; 3 * x + 14)
jac_transform = (x -&gt; 3)
inverse_transform = (x -&gt; (x - 14) / 3)
abstract type Affine &lt;: ConstraintType end

c2 = [bounded(10, 15),
      Constraint{Affine}(transform, jac_transform, inverse_transform, nothing)]
name2 = &quot;constrained_sampled&quot;</code></pre><p>The final parameter is 4-dimensional, defined as a list of i.i.d univariate distributions we make use of the <code>VectorOfParameterized</code> type</p><pre><code class="language-julia hljs">d3 = VectorOfParameterized(repeat([Beta(2,2)],4))
c3 = repeat([no_constraint()],4)
name3 = &quot;Beta&quot;</code></pre><p>The full prior distribution for this setting is created either through building simple distributions and combining</p><pre><code class="language-julia hljs">u1 = ParameterDistribution(d1, c1, name1)
u2 = ParameterDistribution(d2, c2, name2)
u3 = ParameterDistribution(d3, c3, name3)
u = combine_distributions( [u1, u2, u3])</code></pre><p>or an array of the parameter specifications as dictionaries.</p><pre><code class="language-julia hljs">param_dict1 = Dict(&quot;distribution&quot; =&gt; d1, &quot;constraint&quot; =&gt; c1, &quot;name&quot; =&gt; name1)
param_dict2 = Dict(&quot;distribution&quot; =&gt; d2, &quot;constraint&quot; =&gt; c2, &quot;name&quot; =&gt; name2)
param_dict3 = Dict(&quot;distribution&quot; =&gt; d3, &quot;constraint&quot; =&gt; c3, &quot;name&quot; =&gt; name3)
u = ParameterDistribution([param_dict1, param_dict2, param_dict3])</code></pre><p>We can visualize the marginals of the constrained distributions,</p><pre><code class="language-julia hljs">using Plots
plot(u)</code></pre><img src="c9c36ed4.svg" alt="Example block output"/><p>and the unconstrained distributions similarly,</p><pre><code class="language-julia hljs">using Plots
plot(u, constrained = false)</code></pre><img src="21df403d.svg" alt="Example block output"/><h2 id="function-example"><a class="docs-heading-anchor" href="#function-example">Function Distribution Example</a><a id="function-example-1"></a><a class="docs-heading-anchor-permalink" href="#function-example" title="Permalink"></a></h2><p>Here, define a function parameter distribution on <span>$[0,1] \times [1,2]$</span> , bounded by <span>$[-5,-3]$</span> and with correlation lengthscales 0.05. First, we get the packages:</p><pre><code class="language-julia hljs">using EnsembleKalmanProcesses.ParameterDistributions # For `ParameterDistribution`
using Random, Distributions # for `rand` and `Normal`
using Plots
# We must `import` the GRF package, rather than call a `using` statement here
import GaussianRandomFields # for `GaussianRandomFields`</code></pre><p>then, we use the  <a href="https://github.com/PieterjanRobbe/GaussianRandomFields.jl"><code>GaussianRandomFields.jl</code></a> package to define the distribution of choice. This distribution is unbounded. Here we take a <code>Matern</code> kernel, and define our evaluation grid on the domain. We choose 30 degrees of freedom (<code>dofs</code>), so this function distribution is specified through the value of 30 learnable coefficients. </p><pre><code class="language-julia hljs">const GRF = GaussianRandomFields
# Define a `GaussianRandomFields` object
input_dim = 2 # Define a 2D -&gt; 1D function
dofs = 30 # the number of modes defining the distribution
points = [collect(0:0.01:1), collect(1:0.02:2)] # the 2D domain grid (uniform in each dimension)

grfjl_obj = GRF.GaussianRandomField(
   GRF.CovarianceFunction(input_dim, GRF.Matern(0.05, 2)),
   GRF.KarhunenLoeve(dofs),
   points...,
) # the Gaussian Random Field object from the package</code></pre><p>We define our parameter distribution wrapper, where <code>GRFJL()</code> indicates the GRF package used. We also impose bounds into an interval <span>$[-5,-3]$</span> (here applied to the output space).</p><pre><code class="language-julia hljs">grf = GaussianRandomFieldInterface(grfjl_obj, GRFJL()) # our wrapper
pd = ParameterDistribution(
    Dict(
        &quot;distribution&quot; =&gt; grf,
        &quot;constraint&quot; =&gt; bounded(-5, -3),
        &quot;name&quot; =&gt; &quot;func_in_min5_min3&quot;,
    )
) # The ParameterDistribution with constraint in the output space</code></pre><p>We plot 4 samples of this distribution. Samples are taken over the (30-dimensional) degrees of freedom, and then we apply the <code>transform_unconstrained_to_costrained</code> map to (i) build the function distribution, (ii) evaluate it on the numerical grid, and (iii) constrain the output with our prescribed bounds.</p><pre><code class="language-julia hljs">shape = [length(pp) for pp in points]
samples_constrained_flat = [transform_unconstrained_to_constrained(pd, rand(Normal(0,1), dofs)) for i = 1:4]
plts = [contour(points..., reshape(samples_constrained_flat[i], shape...)&#39;, fill = true,) for i =1:4]
plot(plts..., legend=false, size=(800,800))</code></pre><img src="340d04c3.svg" alt="Example block output"/><h2 id="ConstraintType-Examples"><a class="docs-heading-anchor" href="#ConstraintType-Examples">ConstraintType Examples</a><a id="ConstraintType-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#ConstraintType-Examples" title="Permalink"></a></h2><p>For each for the predefined <code>ConstraintType</code>s, we present animations of the resulting constrained prior distribution for</p><pre><code class="language-julia hljs">distribution = Parameterized(Normal(μ, σ))</code></pre><p>where we vary μ and σ respectively. As noted above, in the presence of a nontrivial constraint, μ and σ will no longer correspond to the mean and standard deviation of the prior distribution (which is taken in the physical, constrained space).</p><h3 id="Without-constraints:-&quot;constraint&quot;-no_constraints()"><a class="docs-heading-anchor" href="#Without-constraints:-&quot;constraint&quot;-no_constraints()">Without constraints: <code>&quot;constraint&quot; =&gt; no_constraints()</code></a><a id="Without-constraints:-&quot;constraint&quot;-no_constraints()-1"></a><a class="docs-heading-anchor-permalink" href="#Without-constraints:-&quot;constraint&quot;-no_constraints()" title="Permalink"></a></h3><p>The following specifies a prior based on an unconstrained <code>Normal(0.5, 1)</code> distribution:</p><pre><code class="language-julia hljs">using EnsembleKalmanProcesses.ParameterDistributions # for `Parameterized`, `no_constraint`, `ParameterDistribution`
using Distributions # for `Normal`

param_dict = Dict(
&quot;distribution&quot; =&gt; Parameterized(Normal(0.5, 1)),
&quot;constraint&quot; =&gt; no_constraint(),
&quot;name&quot; =&gt; &quot;unbounded_parameter&quot;,
)

prior = ParameterDistribution(param_dict)</code></pre><p>where <code>no_constraint()</code> automatically defines the identity constraint map</p><pre><code class="language-julia hljs">transform_unconstrained_to_constrained(x) = x</code></pre><p>The following plots show the effect of varying μ and σ in the constrained space (which is trivial here):</p><img src="4b4ff16c.gif" alt="Example block output"/><h3 id="Bounded-below-by-0:-&quot;constraint&quot;-bounded_below(0)"><a class="docs-heading-anchor" href="#Bounded-below-by-0:-&quot;constraint&quot;-bounded_below(0)">Bounded below by 0: <code>&quot;constraint&quot; =&gt; bounded_below(0)</code></a><a id="Bounded-below-by-0:-&quot;constraint&quot;-bounded_below(0)-1"></a><a class="docs-heading-anchor-permalink" href="#Bounded-below-by-0:-&quot;constraint&quot;-bounded_below(0)" title="Permalink"></a></h3><p>The following specifies a prior for a parameter which is bounded below by 0 (i.e. its only physical values are positive), and which has a <code>Normal(0.5, 1)</code> distribution in the unconstrained space:</p><pre><code class="language-julia hljs">using EnsembleKalmanProcesses.ParameterDistributions # for `Parameterized`, `bounded_below`, `ParameterDistribution`
using Distributions # for `Normal`

param_dict = Dict(
&quot;distribution&quot; =&gt; Parameterized(Normal(0.5, 1)),
&quot;constraint&quot; =&gt; bounded_below(0),
&quot;name&quot; =&gt; &quot;bounded_below_parameter&quot;,
)

prior = ParameterDistribution(param_dict)</code></pre><p>where <code>bounded_below(0)</code> automatically defines the constraint map</p><pre><code class="language-julia hljs">transform_unconstrained_to_constrained(x) = exp(x)</code></pre><p>The following plots show the effect of varying μ and σ in the physical, constrained space:</p><img src="3c3928b1.gif" alt="Example block output"/><h3 id="Bounded-above-by-10.0:-&quot;constraint&quot;-bounded_above(10)"><a class="docs-heading-anchor" href="#Bounded-above-by-10.0:-&quot;constraint&quot;-bounded_above(10)">Bounded above by 10.0: <code>&quot;constraint&quot; =&gt; bounded_above(10)</code></a><a id="Bounded-above-by-10.0:-&quot;constraint&quot;-bounded_above(10)-1"></a><a class="docs-heading-anchor-permalink" href="#Bounded-above-by-10.0:-&quot;constraint&quot;-bounded_above(10)" title="Permalink"></a></h3><p>The following specifies a prior for a parameter which is bounded above by ten, and which has a <code>Normal(0.5, 1)</code> distribution in the unconstrained space:</p><pre><code class="language-julia hljs">using EnsembleKalmanProcesses.ParameterDistributions # for `Parameterized`, `bounded_above`, `ParameterDistribution`
using Distributions

param_dict = Dict(
&quot;distribution&quot; =&gt; Parameterized(Normal(0.5, 1)),
&quot;constraint&quot; =&gt; bounded_above(10),
&quot;name&quot; =&gt; &quot;bounded_above_parameter&quot;,
)
prior = ParameterDistribution(param_dict)</code></pre><p>where <code>bounded_above(10)</code> automatically defines the constraint map</p><pre><code class="language-julia hljs">transform_unconstrained_to_constrained(x) = 10 - exp(-x)</code></pre><p>The following plots show the effect of varying μ and σ in the physical, constrained space:</p><img src="b4b11d3a.gif" alt="Example block output"/><h3 id="Bounded-between-5-and-10:-&quot;constraint&quot;-bounded(5,-10)"><a class="docs-heading-anchor" href="#Bounded-between-5-and-10:-&quot;constraint&quot;-bounded(5,-10)">Bounded between 5 and 10: <code>&quot;constraint&quot; =&gt; bounded(5, 10)</code></a><a id="Bounded-between-5-and-10:-&quot;constraint&quot;-bounded(5,-10)-1"></a><a class="docs-heading-anchor-permalink" href="#Bounded-between-5-and-10:-&quot;constraint&quot;-bounded(5,-10)" title="Permalink"></a></h3><p>The following specifies a prior for a parameter whose physical values lie in the range between 5 and 10, and which has a <code>Normal(0.5, 1)</code> distribution in the unconstrained space:</p><pre><code class="language-julia hljs">using EnsembleKalmanProcesses.ParameterDistributions# for `Parameterized`, `bounded`, `ParameterDistribution`
using Distributions # for `Normal`

param_dict = Dict(
&quot;distribution&quot; =&gt; Parameterized(Normal(0.5, 1)),
&quot;constraint&quot; =&gt; bounded(5, 10),
&quot;name&quot; =&gt; &quot;bounded_parameter&quot;,
)

prior = ParameterDistribution(param_dict)</code></pre><p>where <code>bounded(-1, 5)</code> automatically defines the constraint map</p><pre><code class="language-julia hljs">transform_unconstrained_to_constrained(x) = 10 - 5 / (exp(x) + 1)</code></pre><p>The following plots show the effect of varying μ and σ in the physical, constrained space:</p><img src="eaa20f35.gif" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../learning_rate_scheduler/">« Learning rate schedulers</a><a class="docs-footer-nextpage" href="../observations/">Observations and Minibatching »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Thursday 13 March 2025 00:25">Thursday 13 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
