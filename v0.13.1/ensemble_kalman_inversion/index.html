<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ensemble Kalman Inversion · EnsembleKalmanProcesses.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="EnsembleKalmanProcesses.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">EnsembleKalmanProcesses.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation_instructions/">Installation instructions</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../parameter_distributions/">Prior distributions</a></li><li><a class="tocitem" href="../observations/">Observations</a></li><li><a class="tocitem" href="../internal_data_representation/">Internal data representation</a></li><li class="is-active"><a class="tocitem" href>Ensemble Kalman Inversion</a><ul class="internal"><li><a class="tocitem" href="#Constructing-the-Forward-Map"><span>Constructing the Forward Map</span></a></li><li><a class="tocitem" href="#Creating-the-EKI-Object"><span>Creating the EKI Object</span></a></li><li><a class="tocitem" href="#Updating-the-Ensemble"><span>Updating the Ensemble</span></a></li><li><a class="tocitem" href="#Solution"><span>Solution</span></a></li><li><a class="tocitem" href="#Handling-forward-model-failures"><span>Handling forward model failures</span></a></li><li class="toplevel"><a class="tocitem" href="#Sparsity-Inducing-Ensemble-Kalman-Inversion"><span>Sparsity-Inducing Ensemble Kalman Inversion</span></a></li></ul></li><li><a class="tocitem" href="../ensemble_kalman_sampler/">Ensemble Kalman Sampler</a></li><li><a class="tocitem" href="../unscented_kalman_inversion/">Unscented Kalman Inversion</a></li><li><a class="tocitem" href="../localization/">Localization and SEC</a></li><li><a class="tocitem" href="../parallel_hpc/">Parallelism and HPC</a></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/template_example/">Template</a></li><li><a class="tocitem" href="../examples/Cloudy_example/">Cloudy</a></li><li><a class="tocitem" href="../examples/lorenz_example/">Lorenz</a></li><li><a class="tocitem" href="../literated/loss_minimization/">Minimization Loss</a></li><li><a class="tocitem" href="../literated/loss_minimization_sparse_eki/">Sparse Minimization Loss</a></li><li><a class="tocitem" href="../literated/aerosol_activation/">Aerosol activation</a></li><li><a class="tocitem" href="../examples/ClimateMachine_example/">HPC interfacing example: ClimateMachine</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../API/ParameterDistributions/">ParameterDistributions</a></li><li><a class="tocitem" href="../API/Observations/">Observations</a></li><li><a class="tocitem" href="../API/DataContainers/">DataContainers</a></li><li><a class="tocitem" href="../API/EnsembleKalmanProcess/">EnsembleKalmanProcess</a></li><li><a class="tocitem" href="../API/Inversion/">Inversion</a></li><li><a class="tocitem" href="../API/Unscented/">Unscented</a></li><li><a class="tocitem" href="../API/Sampler/">Sampler</a></li><li><a class="tocitem" href="../API/SparseInversion/">SparseInversion</a></li><li><a class="tocitem" href="../API/Localizers/">Localizers</a></li></ul></li><li><a class="tocitem" href="../glossary/">Glossary</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Ensemble Kalman Inversion</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Ensemble Kalman Inversion</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/EnsembleKalmanProcesses.jl/blob/main/docs/src/ensemble_kalman_inversion.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Ensemble-Kalman-Inversion"><a class="docs-heading-anchor" href="#Ensemble-Kalman-Inversion">Ensemble Kalman Inversion</a><a id="Ensemble-Kalman-Inversion-1"></a><a class="docs-heading-anchor-permalink" href="#Ensemble-Kalman-Inversion" title="Permalink"></a></h1><p>One of the ensemble Kalman processes implemented in <code>EnsembleKalmanProcesses.jl</code> is the ensemble Kalman inversion (<a href="http://dx.doi.org/10.1088/0266-5611/29/4/045001">Iglesias et al, 2013</a>). The ensemble Kalman inversion (EKI) is a derivative-free ensemble optimization method that seeks to find the optimal parameters <span>$\theta \in \mathbb{R}^p$</span> in the inverse problem defined by the data-model relation</p><p class="math-container">\[\tag{1} y = \mathcal{G}(\theta) + \eta ,\]</p><p>where <span>$\mathcal{G}$</span> denotes the forward map, <span>$y \in \mathbb{R}^d$</span> is the vector of observations and <span>$\eta  \in \mathbb{R}^d$</span> is additive noise. Note that <span>$p$</span> is the size of the parameter vector <span>$\theta$</span> and <span>$d$</span> the size of the observation vector <span>$y$</span>. Here, we take <span>$\eta \sim \mathcal{N}(0, \Gamma_y)$</span> from a <span>$d$</span>-dimensional Gaussian with zero mean and covariance matrix <span>$\Gamma_y$</span>.  This noise structure aims to represent the correlations between observations.</p><p>The optimal parameters <span>$\theta^* \in \mathbb{R}^p$</span> given relation (1) minimize the loss</p><p class="math-container">\[\mathcal{L}(\theta, y) = \langle \mathcal{G}(\theta) - y \, , \, \Gamma_y^{-1} \left ( \mathcal{G}(\theta) - y \right ) \rangle,\]</p><p>which can be interpreted as the negative log-likelihood given a Gaussian likelihood.</p><p>Denoting the parameter vector of the <span>$j$</span>-th ensemble member at the <span>$n$</span>-th iteration as <span>$\theta^{(j)}_n$</span>, its update equation from <span>$n$</span> to <span>$n+1$</span> under EKI is</p><p class="math-container">\[\tag{2} \theta_{n+1}^{(j)} = \theta_{n}^{(j)} - \dfrac{\Delta t_n}{J}\sum_{k=1}^J \left \langle \mathcal{G}(\theta_n^{(k)}) - \bar{\mathcal{G}}_n \, , \, \Gamma_y^{-1} \left ( \mathcal{G}(\theta_n^{(j)}) - y \right ) \right \rangle \theta_{n}^{(k)} ,\]</p><p>where the subscript <span>$n=1, \dots, N_{\rm it}$</span> indicates the iteration, <span>$J$</span> is the number of members in the ensemble, <span>$\bar{\mathcal{G}}_n$</span> is the mean value of <span>$\mathcal{G}(\theta_n)$</span> across ensemble members,</p><p class="math-container">\[\bar{\mathcal{G}}_n = \dfrac{1}{J}\sum_{k=1}^J\mathcal{G}(\theta_n^{(k)}) ,\]</p><p>and angle brackets denote the Euclidean inner product. By multiplying with <span>$\Gamma_y^{-1}$</span> we render the inner product non-dimensional.</p><p>The EKI algorithm is considered converged when the ensemble achieves sufficient consensus/collapse in parameter space. The final estimate <span>$\bar{\theta}_{N_{\rm it}}$</span> is taken to be the ensemble mean at the final iteration,</p><p class="math-container">\[\bar{\theta}_{N_{\rm it}} = \dfrac{1}{J}\sum_{k=1}^J\theta_{N_{\rm it}}^{(k)}.\]</p><p>For typical applications, a near-optimal solution <span>$\theta$</span> can be found after as few as 10 iterations of the algorithm, or <span>$10\cdot J$</span> evaluations of the forward model <span>$\mathcal{G}$</span>. The basic algorithm requires <span>$J \geq p$</span>, and better performance is often seen with larger ensembles; a good rule of thumb is to start with <span>$J=10p$</span>. The algorithm also extends to <span>$J &lt; p$</span> , using localizers to maintain performance in these situations (see the Localizers.jl module).</p><h2 id="Constructing-the-Forward-Map"><a class="docs-heading-anchor" href="#Constructing-the-Forward-Map">Constructing the Forward Map</a><a id="Constructing-the-Forward-Map-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-the-Forward-Map" title="Permalink"></a></h2><p>The forward map <span>$\mathcal{G}$</span> maps the space of unconstrained parameters <span>$\theta \in \mathbb{R}^p$</span> to the space of outputs <span>$y \in \mathbb{R}^d$</span>. In practice, the user may not have access to such a map directly. Consider a situation where the goal is to learn a set of parameters <span>$\phi$</span> of a dynamical model <span>$\Psi: \mathbb{R}^p \rightarrow \mathbb{R}^o$</span>, given observations <span>$y \in \mathbb{R}^d$</span> and a set of constraints on the value of <span>$\phi$</span>. Then, the forward map may be constructed as</p><p class="math-container">\[\mathcal{G} = \mathcal{H} \circ \Psi \circ \mathcal{T}^{-1},\]</p><p>where <span>$\mathcal{H}: \mathbb{R}^o \rightarrow \mathbb{R}^d$</span> is the observation map and <span>$\mathcal{T}$</span> is the transformation map from constrained to unconstrained parameter spaces, such that <span>$\mathcal{T}(\phi) = \theta$</span>. A family of standard transformation maps and their inverse are available in the <code>ParameterDistributions</code> module.</p><h2 id="Creating-the-EKI-Object"><a class="docs-heading-anchor" href="#Creating-the-EKI-Object">Creating the EKI Object</a><a id="Creating-the-EKI-Object-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-the-EKI-Object" title="Permalink"></a></h2><p>An ensemble Kalman inversion object can be created using the <code>EnsembleKalmanProcess</code> constructor by specifying the <code>Inversion()</code> process type.</p><p>Creating an ensemble Kalman inversion object requires as arguments:</p><ol><li>An initial parameter ensemble, <code>Array{Float, 2}</code> of size <code>[p × J]</code>;</li><li>The mean value of the observed outputs, a vector of size <code>[d]</code>;</li><li>The covariance of the observational noise, a matrix of size <code>[d × d]</code>;</li><li>The <code>Inversion()</code> process type.</li></ol><p>A typical initialization of the <code>Inversion()</code> process takes a user-defined <code>prior</code>, a summary of the observation statistics given by the mean <code>y</code> and covariance <code>obs_noise_cov</code>, and a desired number of members in the ensemble,</p><pre><code class="language-julia hljs">using EnsembleKalmanProcesses
using EnsembleKalmanProcesses.ParameterDistributions

J = 50  # number of ensemble members
initial_ensemble = construct_initial_ensemble(prior, J) # Initialize ensemble from prior

ekiobj = EnsembleKalmanProcess(initial_ensemble, y, obs_noise_cov, Inversion())</code></pre><p>See the <a href="../parameter_distributions/#parameter-distributions">Prior distributions</a> section to learn about the construction of priors in EnsembleKalmanProcesses.jl. The prior is assumed to be over the unconstrained parameter space where <span>$\theta$</span> is defined. For applications where enforcing parameter bounds is necessary, the <code>ParameterDistributions</code> module provides functions to map from constrained to unconstrained space and vice versa. </p><h2 id="Updating-the-Ensemble"><a class="docs-heading-anchor" href="#Updating-the-Ensemble">Updating the Ensemble</a><a id="Updating-the-Ensemble-1"></a><a class="docs-heading-anchor-permalink" href="#Updating-the-Ensemble" title="Permalink"></a></h2><p>Once the ensemble Kalman inversion object <code>ekiobj</code> has been initialized, any number of updates can be performed using the inversion algorithm.</p><p>A call to the inversion algorithm can be performed with the <code>update_ensemble!</code> function. This function takes as arguments the <code>ekiobj</code> and the evaluations of the forward map at each member of the current ensemble. The <code>update_ensemble!</code> function then stores the new updated ensemble and the inputted forward map evaluations in <code>ekiobj</code>. </p><p>A typical use of the <code>update_ensemble!</code> function given the ensemble Kalman inversion object <code>ekiobj</code>, the dynamical model <code>Ψ</code> and the observation map <code>H</code> is</p><pre><code class="language-julia hljs"># Given:
# Ψ (some black box simulator)
# H (some observation of the simulator output)
# prior (prior distribution and parameter constraints)

N_iter = 20 # Number of steps of the algorithm

for n in 1:N_iter
    ϕ_n = get_ϕ_final(prior, ekiobj) # Get current ensemble in constrained &quot;ϕ&quot;-space
    G_n = [H(Ψ(ϕ_n[:, i])) for i in 1:J]
    g_ens = hcat(G_n...) # Evaluate forward map 
    update_ensemble!(ekiobj, g_ens) # Update ensemble
end</code></pre><p>In the previous update, note that the parameters stored in <code>ekiobj</code> are given in the unconstrained Gaussian space where the EKI algorithm is performed. The map <span>$\mathcal{T}^{-1}$</span> between this unconstrained space and the (possibly constrained) physical space of parameters is encoded in the <code>prior</code> object. The dynamical model <code>Ψ</code> accepts as inputs the parameters in (possibly constrained) physical space, so it is necessary to use the getter <code>get_ϕ_final</code> which applies <code>transform_unconstrained_to_constrained</code> to the ensemble. See the <a href="../parameter_distributions/#parameter-distributions">Prior distributions</a> section for more details on parameter transformations.   </p><h2 id="Solution"><a class="docs-heading-anchor" href="#Solution">Solution</a><a id="Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Solution" title="Permalink"></a></h2><p>The EKI algorithm drives the initial ensemble, sampled from the prior, towards the support region of the posterior distribution. The algorithm also drives the ensemble members towards consensus. The optimal parameter <code>θ_optim</code> found by the algorithm is given by the mean of the last ensemble (i.e., the ensemble after the last iteration),</p><pre><code class="language-julia hljs">θ_optim = get_u_mean_final(ekiobj) # optimal parameter</code></pre><p>To obtain the optimal value in the constrained space, we use the getter with the constrained prior as input</p><pre><code class="language-julia hljs">ϕ_optim = get_ϕ_mean_final(prior, ekiobj) # the optimal physical parameter value</code></pre><h2 id="Handling-forward-model-failures"><a class="docs-heading-anchor" href="#Handling-forward-model-failures">Handling forward model failures</a><a id="Handling-forward-model-failures-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-forward-model-failures" title="Permalink"></a></h2><p>In situations where the forward model <span>$\mathcal{G}$</span> represents a diagnostic of a complex computational model, there might be cases where for some parameter combinations <span>$\theta$</span>, attempting to evaluate <span>$\mathcal{G}(\theta)$</span> may result in model failure (defined as returning a <code>NaN</code> from the point of view of this package). In such cases, the EKI update equation (2) must be modified to handle model failures.</p><p><code>EnsembleKalmanProcesses.jl</code> implements such modifications through the <code>FailureHandler</code> structure, an input to the <code>EnsembleKalmanProcess</code> constructor. Currently, the only failsafe modification available is <code>SampleSuccGauss()</code>, described in <a href="https://doi.org/10.1029/2022MS003105">Lopez-Gomez et al (2022)</a>.</p><p>To employ this modification, construct the EKI object as</p><pre><code class="language-julia hljs">using EnsembleKalmanProcesses
using EnsembleKalmanProcesses.ParameterDistributions

J = 50  # number of ensemble members
initial_ensemble = construct_initial_ensemble(prior, J) # Initialize ensemble from prior

ekiobj = EnsembleKalmanProcess(
    initial_ensemble,
    y,
    obs_noise_cov,
    Inversion(),
    failure_handler_method = SampleSuccGauss())</code></pre><div class="admonition is-info"><header class="admonition-header">Forward model requirements when using FailureHandlers</header><div class="admonition-body"><p>The user must determine if a model run has &quot;failed&quot;, and replace the output <span>$\mathcal{G}(\theta)$</span> with <code>NaN</code>. The <code>FailureHandler</code> takes care of the rest.</p></div></div><p>A description of the algorithmic modification is included below.</p><h3 id="SampleSuccGauss()"><a class="docs-heading-anchor" href="#SampleSuccGauss()"><code>SampleSuccGauss()</code></a><a id="SampleSuccGauss()-1"></a><a class="docs-heading-anchor-permalink" href="#SampleSuccGauss()" title="Permalink"></a></h3><p>The <code>SampleSuccGauss()</code> modification is based on updating all ensemble members with a distribution given by only the successful parameter ensemble. Let <span>$\Theta_{s,n}=[ \theta^{(1)}_{s,n},\dots,\theta^{(J_s)}_{s,n}]$</span> be the successful ensemble, for which each evaluation <span>$\mathcal{G}(\theta^{(j)}_{s,n})$</span> does not fail, and let <span>$\theta_{f,n}^{(k)}$</span> be the ensemble members for which the evaluation <span>$\mathcal{G}(\theta^{(k)}_{f,n})$</span> fails. The successful ensemble <span>$\Theta_{s,n}$</span> is updated to <span>$\Theta_{s,n+1}$</span> using expression (2), and each failed ensemble member as</p><p class="math-container">\[    \theta_{f,n+1}^{(k)} \sim \mathcal{N} \left({m}_{s, {n+1}}, \Sigma_{s, n+1} \right),\]</p><p>where</p><p class="math-container">\[    {m}_{s, {n+1}} = \dfrac{1}{J_s}\sum_{j=1}^{J_s} \theta_{s,n+1}^{(j)}, \qquad \Sigma_{s, n+1} = \mathrm{Cov}(\theta_{s, n+1}, \theta_{s, n+1}) + \kappa_*^{-1}\mu_{s,1}I_p.\]</p><p>Here, <span>$\kappa_*$</span> is a limiting condition number, <span>$\mu_{s,1}$</span> is the largest eigenvalue of the sample covariance <span>$\mathrm{Cov}(\theta_{s, n+1}, \theta_{s, n+1})$</span> and <span>$I_p$</span> is the identity matrix of size <span>$p\times p$</span>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This modification is not a magic bullet. If large fractions of ensemble members fail during an iteration, this will degenerate the span of the ensemble.</p></div></div><h1 id="Sparsity-Inducing-Ensemble-Kalman-Inversion"><a class="docs-heading-anchor" href="#Sparsity-Inducing-Ensemble-Kalman-Inversion">Sparsity-Inducing Ensemble Kalman Inversion</a><a id="Sparsity-Inducing-Ensemble-Kalman-Inversion-1"></a><a class="docs-heading-anchor-permalink" href="#Sparsity-Inducing-Ensemble-Kalman-Inversion" title="Permalink"></a></h1><p>We include Sparsity-inducing Ensemble Kalman Inversion (SEKI) to add approximate <span>$L^0$</span> and <span>$L^1$</span> penalization to the EKI (<a href="https://doi.org/10.48550/arXiv.2007.06175">Schneider, Stuart, Wu, 2020</a>).</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The algorithm suffers from robustness issues, and therefore we urge caution in using the tool</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../internal_data_representation/">« Internal data representation</a><a class="docs-footer-nextpage" href="../ensemble_kalman_sampler/">Ensemble Kalman Sampler »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 21 October 2022 19:33">Friday 21 October 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
